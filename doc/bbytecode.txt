#
#every integers have to be stored in little endian and in 64bits
#
constants:
    (each identifier has to be converted to a string in the constants)
    array of constants used by ASTs or instruction
    always contains
        $i as 0th
        0b as 1th
        1b as 2th
    example:
        constants = [3.5, "a string", 42, 0b, $i, "i"]
    for a ountt:
        0x49 64bits(for int value little endian)
    for a string:
        0x53 (chars of the string as 1byte each NULL terminated)
    for a floap:
        0x46 64bits(EEE754 Double precision 64-bit little endian)

    

Asts:
    array of index of asts in the bytecode
    example:
        Asts = [0,10] # made by the interpreter


PASS:
    0x00 

FOR:
    0x01 64bits(var name idx in constants) 64bits(start AST idx) 64bits(end AST idx) 64bits(END_FOR idx)

END_FOR:
    0x02 64bits(FOR idx)

WHILE
    0x01 64bits(start AST idx) 64bits(END_WHILE idx)

END_WHILE:
    0x02 64bits(WHILE idx)

PROCEED:
    0x03 0x01 64bits(FOR / WHILE idx) 

STOP:
    0x03 0x01 64bits(END_FOR / END_WHILE idx) 

GOTO:
    0x03 0x00 64bits(label name idx in constants)
EXPR:
    0x04 64bits(ast idx)

END_AST / END_CONSTANTS / END_INSTRUCTION:
    0x00 0x00 0x00 0x00 0x00 0x00 (indicate definition of all ast / const / insts is finished)



ast -> push / operation

    +       -> push a; push b; add;
a       b   -> stack_max_len=2 (bc. 2 push)

            +       -> push a; push b; mul; push c; add;
    *           c   -> constants = ["a", "b", "c"] 
a       b           ->     ________________________________________________________
                           |              |              |    |              |    |
(64bits)0x03 (64bits)0x05  0x01 0x01 0x00 0x01 0x01 0x01 0x04 0x01 0x01 0x02 0x03



AST : 64bits(stack max len) 64bits(AST_instruction len) ast_instructions;

ast_instructions:
    push : 0x01 (0x01/0x02 (varcall / constants idx)) 64bits(idx)
        ex: push a;   = 0x01 0x01 (64bits)0x00   (constants = ["a", 90])
        ex: push 90;  = 0x01 0x02 (64bits)0x01   (constants = ["a", 90])
        ex: push "a"; = 0x01 0x02 (64bits)0x00   (constants = ["a", 90])


    call_func : 0x02
        push each from argument from right to left then push the number
        of arg as ount push the function
        ex : 
            //we want to call println with "bonjour"
            //constans = ["println", 1, "bonjour"]
            push "bonjour";     |   0x01 0x02 (64bits)0x02
            push 1;             |   0x01 0x02 (64bits)0x01
            push println;       |   0x01 0x01 (64bits)0x00
            call_func;          |   0x02

    annonymous_function:
        0x03 64bits(nbr of instructions) instructions 
    pop : 0x04
        erase the top of the stack

    // the operation are done on the 2 top value of the stack
    add : 0x05
    sub : 0x06
    mul : 0x07
    div : 0x08

    assign : 0xF0
        assign the top of the stack to the var with the name stored as string in second top of the stack
        ex:
            //we want to assign 3 to a (a = 3)
            //constants = [3, "a"]
            push "a";  |   0x01 0x02 (64bits)0x01
            push 3;    |   0x01 0x02 (64bits)0x00
            assign;    |   0xF0
    push_dot : 0xF1
        same as push but for things that require dot operator (ex : math.pi)
        push the container then push the name of the var as string and do push_dot
        it will remove the 2 top of the stack
        ex:
            //we want to push math.pi
            //constants = ["math", "pi"]
            push math;  |   0x01 0x01 (64bits)0x00 //push value of math (a module)
            push "pi";  |   0x01 0x02 (64bits)0x01 // push the constant "pi"
            push_dot;   |   0xF1 so it will push math.pi

        ex2:
            //we want to push a.b.c
            //constants = ["a", "b", "c"]
            push a
            push "b"
            push_dot
            push "c"
            push_dot
    assign_dot : 0xF2
        set the value of the top of the stack into the 2 top in 3 top
        push container then push name of var as string then push value then assign_dot
        it will remove 3 top of the stack
        ex:
            //we want to asssign math.pi to 20 (math.pi = 20)
            //constants = ["math", "pi", 20]
            push math;  |   0x01 0x01 (64bits)0x00 //push value of math (a module)
            push "pi";  |   0x01 0x02 (64bits)0x01 // push the constant "pi"
            push 20;    |   0x01 0x01 (64bits)0x02 //push value 20
            assign_dot; |   0xF2

################ bytecode file format #################

magical number      |   0x2e 0x53 0x63 0x2e
constants section   |   64bits(nbr of constants)
                    |   constants
                    |   0x00 0x00 0x00 0x00 0x00 0x00
asts section        |   64bits(nbr of ast)
                    |   asts
                    |   0x00 0x00 0x00 0x00 0x00 0x00
instructions sec    |   64(bits nbr of instructions)
                    |   instructions
                    |   0x00 0x00 0x00 0x00 0x00 0x00