                    SULFUR BYTECODE

D<    =   EEE754 Double precision 64-bit little endian
8B<   =   64bits int little endian

every addresses are 8B<
every 0x notation are 1 byte execept when they are addresses


at 0x00 (in file) : magical number '.Su.'
at 0x04 (in file) : a 8B< representing the addreess of the first instruction in the file

constants in file:
    ount    : 'I' value(8B<)                  : size = 9
    string  : 'S' string_chars(as 1B) 0x0     : size = 2 + strlen
    floap   : 'F' value(D<)                   : size = 9



The Interpreter:
    Obj_stack : a stack of object  (used when evaluating expressions)
    Vars : dict  of str to Object (contains global variables)
    call_stack : a stack of addresses (used when call is hit)
    func_call_stack : a stack of addresses (used when func_call is hit)
    var_stack : a stack of Vars (contains local variables of the current scope)

    at the start the interpreter jump to the first instruction where its addrees is stored at 0x04


Instruction set:
    //we will representer stack like this [bottom, middle, top]
    # INSTRUCTION_NAME (parameters)

    END :
        0x00    : stop the current program
    
    PASS:
        0x01    : do nothing
    
    JMP (addr):
        0x02 addr(8B<) : jump to addr
    
    JMP_AT:
        0x03    : obj_stack : [..., addr] jump to addr(if it is an ount) and pop it
    
    JMP_IF:
        0x04    : obj_stack : [..., v, a] jump to a if v is evaluated true and pop them always
    
    JMP_IFN:
        0x05    : obj_stack : [..., v, a] jump to a if v is evaluated false and pop them always

    CALL:
        0x06    : obj_stack : [..., a] store the current address in the call_stack, jump to a and pop it
    LONG_PASS int:
        0xFF int(8b<) : do nothing but can store an unsigned int 